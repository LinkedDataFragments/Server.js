#!/usr/bin/env node
/*! @license MIT Â©2013-2017 Ruben Verborgh and Ruben Taelman, Ghent University - imec */
/* Standalone Linked Data Fragments Server */

var cluster = require('cluster'),
    ComponentsLoader = require('componentsjs').Loader;

// Parse arguments
var args = process.argv.slice(2);
if (args.length < 1 || args.length > 4 || /^--?h(elp)?$/.test(args[0])) {
  console.log('usage: server config.json [port [workers [componentConfigUri]]]');
  return process.exit(1);
}

var cliPort = parseInt(args[1], 10),
    cliWorkers = parseInt(args[2], 10),
    configUri = args[3] || 'urn:ldf-server:my';

var loader = new ComponentsLoader({ scanGlobal: true });
loader.registerAvailableModuleResources()
  .then(function () {
    // Start up a cluster master
    if (cluster.isMaster) {
      return loader.getConfigConstructorFromUrl(configUri, args[0])
        .then(function (constructor) {
          return constructor.makeArguments(true).then(function (args) {
            startClusterMaster(args[0]);
          });
        })
        .catch(function (e) {
          console.error('Config error:');
          console.error(e);
          process.exit(1);
        });
    }
    else {
      return loader.instantiateFromUrl(configUri, args[0])
        .then(function (worker) {
          worker.run(cliPort);
        })
        .catch(function (e) {
          console.error('Instantiation error:');
          console.error(e);
          process.exit(1);
        });
    }
  })
  .catch(function (e) {
    console.error('Component definition error:');
    console.error(e);
    process.exit(1);
  });

function startClusterMaster(config) {
  var workers = cliWorkers || config.workers || 1;

  // Create workers
  console.log('Master %d running.', process.pid);
  for (var i = 0; i < workers; i++)
    cluster.fork();

  // Respawn crashed workers
  cluster.on('listening', function (worker) {
    worker.once('exit', function (code, signal) {
      if (!worker.exitedAfterDisconnect) {
        console.log('Worker %d died with %s. Starting new worker.',
          worker.process.pid, code || signal);
        cluster.fork();
      }
    });
  });

  // Disconnect from cluster on SIGINT, so that the process can cleanly terminate
  process.once('SIGINT', function () {
    cluster.disconnect();
  });

  // Respawn workers one by one when receiving a SIGHUP signal
  process.on('SIGHUP', function respawn() {
    console.log('Respawning workers of master %d.', process.pid);
    process.addListener('SIGHUP', respawnPending);
    process.removeListener('SIGHUP', respawn);

    // Retrieve a list of old workers that will be replaced by new ones
    var workers = Object.keys(cluster.workers).map(function (id) { return cluster.workers[id]; });
    (function respawnNext() {
      // If there are still old workers, respawn a new one
      if (workers.length) {
        // Wait until the new worker starts listening to kill the old one
        var newWorker = cluster.fork();
        newWorker.once('listening', function () {
          var worker = workers.pop();
          if (!worker)
            return newWorker.kill(), respawnNext(); // Dead workers are replaced automatically
          worker.once('exit', function () {
            console.log('Worker %d replaces killed worker %d.',
              newWorker.process.pid, worker.process.pid);
            respawnNext();
          });
          worker.kill();
          newWorker.removeListener('exit', abort);
        });
        // Abort the respawning process if creating a new worker fails
        newWorker.on('exit', abort);
        function abort(code, signal) {
          if (!newWorker.suicide) {
            console.log('Respawning aborted because worker %d died with %s.',
              newWorker.process.pid, code || signal);
            process.addListener('SIGHUP', respawn);
            process.removeListener('SIGHUP', respawnPending);
          }
        }
      }
      // No old workers left, so respawning has finished
      else {
        process.addListener('SIGHUP', respawn);
        process.removeListener('SIGHUP', respawnPending);
        console.log('Respawned all workers of master %d.', process.pid);
      }
    })();
    function respawnPending() { console.log('Respawning already in progress'); }
  });
}
