/*! @license MIT Â©2015-2016 Ruben Verborgh, Ghent University - imec */
/* A TriplePatternFragmentsController responds to requests for fragments */

var Controller = require('./Controller'),
    url = require('url'),
    _ = require('lodash'),
    N3Util = require('n3').Util;

// Creates a new TriplePatternFragmentsController
function TriplePatternFragmentsController(options) {
  if (!(this instanceof TriplePatternFragmentsController))
    return new TriplePatternFragmentsController(options);
  options = options || {};
  Controller.call(this, options);
  this._routers = options.routers || [];
  this._extensions = options.extensions || [];
}
Controller.extend(TriplePatternFragmentsController);

// The base name of the view to be used for this controller
TriplePatternFragmentsController.prototype.viewName = 'TriplePatternFragments';

// The required features the given datasource must have
TriplePatternFragmentsController.prototype.supportsDatasource = function (datasource) {
  return datasource.supportedFeatures.triplePattern;
};

// Try to serve the requested fragment
TriplePatternFragmentsController.prototype._handleRequest = function (request, response, next) {
  // Create the query from the request by calling the fragment routers
  var requestParams = { url: request.parsedUrl },
      query = this._routers.reduce(function (query, router) {
        try { router.extractQueryParams(requestParams, query); }
        catch (e) { /* ignore routing errors */ }
        return query;
      }, { features: [] });

  // Execute the query on the data source
  var datasourceSettings = query.features.datasource && this._datasources[query.datasource];
  delete query.features.datasource;
  delete query.features.quadPattern; // Every tpf is a qpf, so ignore this feature here for tpf-specific datasources.
  if (!datasourceSettings || !datasourceSettings.datasource.supportsQuery(query) ||
      !this.supportsDatasource(datasourceSettings.datasource))
    return next();

  // Generate the query result
  var view = this._negotiateView(this.viewName, request, response),
      settings = this._createFragmentMetadata(request, query, datasourceSettings);
  settings.results = datasourceSettings.datasource.select(query,
                     function (error) { error && next(error); });

  // Execute the extensions and render the query result
  var extensions = this._extensions, extensionId = 0;
  (function nextExtension(error) {
    // Log a possible error with the previous extension
    if (error)
      process.stderr.write(error.stack + '\n');
    // Execute the next extension
    if (extensionId < extensions.length)
      extensions[extensionId++].handleRequest(request, response, nextExtension, settings);
    // Render the query result
    else
      view.render(settings, request, response);
  })();
};

// Create the template url for requesting triple patterns
TriplePatternFragmentsController.prototype._createTemplateUrl = function (datasourceUrl) {
  return datasourceUrl + '{?subject,predicate,object}';
};

// Create parameterized pattern string for triple patterns
TriplePatternFragmentsController.prototype._createPatternString = function (query) {
  return '{ ' +
         (query.subject              ? '<' + query.subject   + '> ' : '?s ') +
         (query.predicate            ? '<' + query.predicate + '> ' : '?p ') +
         (N3Util.isIRI(query.object) ? '<' + query.object    + '> ' : (query.object || '?o')) + ' }';
};

// Creates metadata about the requested fragment
TriplePatternFragmentsController.prototype._createFragmentMetadata =
function (request, query, datasourceSettings) {
  // TODO: these URLs should be generated by the routers
  var requestUrl = request.parsedUrl,
      // maintain the originally requested query string to avoid encoding differences
      origQuery = request.url.replace(/[^?]+/, ''),
      pageUrl = url.format(requestUrl).replace(/\?.*/, origQuery),
      paramsNoPage = _.omit(requestUrl.query, 'page'),
      currentPage = parseInt(requestUrl.query.page, 10) || 1,
      datasourceUrl = url.format(_.omit(requestUrl, 'query')),
      fragmentUrl = url.format(_.defaults({ query: paramsNoPage }, requestUrl)),
      fragmentPageUrlBase = fragmentUrl + (/\?/.test(fragmentUrl) ? '&' : '?') + 'page=',
      indexUrl = url.format(_.omit(requestUrl, 'search', 'query', 'pathname')) + '/';

  // Generate a textual representation of the pattern
  query.patternString = this._createPatternString(query);

  return {
    datasource: _.assign(_.omit(datasourceSettings, 'datasource'), {
      index: indexUrl + '#dataset',
      url: datasourceUrl + '#dataset',
      templateUrl: this._createTemplateUrl(datasourceUrl),
    }),
    fragment: {
      url: fragmentUrl,
      pageUrl: pageUrl,
      firstPageUrl: fragmentPageUrlBase + '1',
      nextPageUrl: fragmentPageUrlBase + (currentPage + 1),
      previousPageUrl: currentPage > 1 ? fragmentPageUrlBase + (currentPage - 1) : null,
    },
    query: query,
    prefixes: this._prefixes,
    datasources: this._datasources,
  };
};

// Close all data sources
TriplePatternFragmentsController.prototype.close = function () {
  for (var datasourceName in this._datasources) {
    try { this._datasources[datasourceName].datasource.close(); }
    catch (error) { /* ignore closing errors */ }
  }
};

module.exports = TriplePatternFragmentsController;
